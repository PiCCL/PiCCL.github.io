import{c as o,G as d,o as r}from"./index-bLxK5Vhm.js";const n={class:"markdown-body"},h={__name:"020Operators",setup(i,{expose:e}){return e({frontmatter:{}}),(c,t)=>(r(),o("div",n,t[0]||(t[0]=[d("<h1>Operator</h1><p>Operators manipulate Graphic Objects and return new Graphic Objects.</p><h2>union(objects): Glyph</h2><p>Combines multiple graphic objects into a single entity and returns the merged graphic object.</p><h3>Parameters</h3><table><thead><tr><th>parameter</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>objects</td><td>GraphicObject[]</td><td>An array of graphic objects to be merged. Later elements in the array will obscure earlier ones.</td></tr></tbody></table><h3>returns</h3><p>Returns the merged graphic object, of type <code>Glyph</code>. You can set constraint relationships between the merged elements on this object.</p><h2>intersect(object1, object2, ignore): Glyph</h2><p>Performs an intersection operation on two graphic objects and returns the result. The color of the result depends on the second object.</p><h3>Parameters</h3><table><thead><tr><th>parameter</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>object1</td><td>GraphicObject</td><td>The first element participating in the intersection operation.</td></tr><tr><td>object2</td><td>GraphicObject</td><td>The second element participating in the intersection operation.</td></tr><tr><td>ignore?</td><td>GraphicObject[]</td><td>Elements to be ignored during the intersection operation. Ignored elements will be directly overlaid on the final result without participating in the operation. Default is <code>[]</code>.</td></tr></tbody></table><h3>returns</h3><p>Returns the result of the intersection operation, of type <code>Glyph</code>. You can set constraint relationships between the participating elements on this object.</p><h2>substract(object1, object2, ignore): Glyph</h2><p>Subtracts the shape of the second graphic object from the first.</p><h3>Parameters</h3><table><thead><tr><th>parameter</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>object1</td><td>GraphicObject</td><td>The element to be subtracted from.</td></tr><tr><td>object2</td><td>GraphicObject</td><td>The element used for subtraction.</td></tr><tr><td>ignore?</td><td>GraphicObject[]</td><td>Elements to be ignored during the subtraction operation. Ignored elements will be directly overlaid on the final result without participating in the operation. Default is <code>[]</code>.</td></tr></tbody></table><h3>returns</h3><p>Returns the result of the subtraction operation, of type <code>Glyph</code>. You can set constraint relationships between the participating elements on this object.</p><h2>xor(object1, object2, ignore): Glyph</h2><p>Performs an XOR operation on two graphic objects and returns the result. <code>a xor b = (a - b) + (b - a)</code>, meaning the non-overlapping parts of both elements are retained.</p><h3>Parameters</h3><table><thead><tr><th>parameter</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>object1</td><td>GraphicObject</td><td>The first element participating in the XOR operation.</td></tr><tr><td>object2</td><td>GraphicObject</td><td>The second element participating in the XOR operation.</td></tr><tr><td>ignore?</td><td>GraphicObject[]</td><td>Elements to be ignored during the XOR operation. Ignored elements will be directly overlaid on the final result without participating in the operation. Default is <code>[]</code>.</td></tr></tbody></table><h3>returns</h3><p>Returns the result of the XOR operation, of type <code>Glyph</code>. You can set constraint relationships between the participating elements on this object.</p><h2>repeat(object, key?): Collection</h2><p>Repeats a graphic object multiple times and returns the result as a single entity.</p><p>Each repeated instance is assigned to different data. If <code>key</code> is specified, the data is grouped by the key, and each instance is assigned to a data group.</p><h3>Parameters</h3><table><thead><tr><th>parameter</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>object</td><td>GraphicObject</td><td>The graphic object to be repeated.</td></tr><tr><td>key?</td><td>string</td><td>The column name for data grouping. If specified, data will be grouped by the values in this column.</td></tr></tbody></table><h3>returns</h3><p>Returns an object containing all repeated instances, of type <code>Collection</code>. You can set the <code>layout</code> for multiple repeated instances on this object.</p><h2>duplicate(object, number): Collection</h2><p>Repeats a graphic object a specified number of times and returns the result as a single entity.</p><p>Each duplicated instance is identical.</p><h3>Parameters</h3><table><thead><tr><th>parameter</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>object</td><td>GraphicObject</td><td>The graphic object to be duplicated.</td></tr><tr><td>number</td><td>number | string</td><td>The number of repetitions. If a number, it specifies the exact number of repetitions; if a string, the number of repetitions is dynamically determined by the values in the specified column of the data.</td></tr></tbody></table><h3>returns</h3><p>Returns an object containing all duplicated instances, of type <code>Collection</code>. You can set the <code>layout</code> for multiple duplicated instances on this object.</p><h2>divide(object, direction, {key?, sizeEncode?, gap?}): GraphicObject</h2><p>Divides a graphic object into several segments and transforms the original graphic into a composite containing all segments. Returns the segments produced by the division.</p><p>Each segment is assigned to different data. If <code>key</code> is specified, the data is grouped by the key, and each segment is assigned to a data group.</p><h3>Parameters</h3><table><thead><tr><th>parameter</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>object</td><td>GraphicObject</td><td>The graphic object to be divided.</td></tr><tr><td>direction</td><td>string</td><td>The direction of division. For rectangles or images, options are <code>&quot;x&quot;</code> or <code>&quot;y&quot;</code>; for circles or arcs, options are <code>&quot;angular&quot;</code> or <code>&quot;radial&quot;</code>.</td></tr><tr><td>key?</td><td>string</td><td>The column name for data grouping. If specified, instances will be grouped by the values in this column.</td></tr><tr><td>sizeEncode?</td><td>string</td><td>If specified, the size of each segment is determined by the values in the specified column of the data.</td></tr><tr><td>gap</td><td>number</td><td>The spacing between segments. Default is <code>0</code>.</td></tr></tbody></table><h3>returns</h3><p>Returns the segments produced by the division.</p><h2>link(object, {filter?, linkByData?, endEdge?, startEdge?, type?, shape?, curveness?, overlay?, â€¦style?}): LinkResult</h2><p>Adds connections to the original graphic and returns the merged result.</p><p>Connections support two methods: sequential connection or pairwise connection. Before connecting, you need to set <code>linkId</code> for the elements to be connected.</p><ul><li><strong>Sequential connection</strong>: Elements with the same <code>linkId</code> are grouped and connected sequentially.</li><li><strong>Pairwise connection</strong>: Requires independent data. Connections are made by matching <code>linkId</code> with the values in the <code>&quot;source_id&quot;</code> and <code>&quot;target_id&quot;</code> columns of the data.</li></ul><p>When connecting two elements, you can specify which edges of the elements to connect. For the starting element, the connection starts from this edge, referred to as <code>startEdge</code>. For the ending element, the connection enters through this edge, referred to as <code>endEdge</code>.</p><h3>Parameters</h3><table><thead><tr><th>parameter</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>object</td><td>GraphicObject</td><td>The object to which connections are added.</td></tr><tr><td>filter?</td><td>string | GraphicObject</td><td>If set, only graphic objects of the specified type will be connected. Default is <code>&quot;*&quot;</code>, meaning all objects are connected.</td></tr><tr><td>linkByData?</td><td>boolean</td><td>If set to <code>true</code>, connections are made based on independent data; otherwise, all specified elements are connected sequentially.</td></tr><tr><td>endEdge?</td><td>string</td><td>The edge of the starting element where the connection begins.</td></tr><tr><td>startEdge?</td><td>string</td><td>The edge of the ending element where the connection ends.</td></tr><tr><td>type?</td><td>string</td><td>The type of connection, options are <code>&quot;link&quot;</code> or <code>&quot;band&quot;</code>. Default is <code>&quot;band&quot;</code>.</td></tr><tr><td>shape?</td><td>string</td><td>The shape of the connection, options are <code>&quot;straight&quot;</code>, <code>&quot;arc&quot;</code>, or <code>&quot;bezier&quot;</code>. Default is <code>&quot;straight&quot;</code>.</td></tr><tr><td>curveness?</td><td>number</td><td>The curvature of the curve when <code>shape</code> is <code>&quot;bezier&quot;</code>. Default is <code>30</code>.</td></tr><tr><td>overlay?</td><td>string</td><td>Whether the connection is overlaid above or below the original graphic. Options are <code>&quot;back&quot;</code> or <code>&quot;top&quot;</code>. Default is <code>&quot;back&quot;</code>.</td></tr><tr><td>style?</td><td>Style</td><td>The style of the connection.</td></tr></tbody></table><h3>returns</h3><p>Returns an object combining the original graphic and the connection lines, of type <code>LinkResult</code>.</p>",56)])))}};export{h as default};
